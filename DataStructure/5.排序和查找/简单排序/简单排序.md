# 简单排序

**前提** 

统一格式

```xc
void X_Sort(ElementType A[], int N)
```


大部分情况下，为了简单起见，讨论从小到大整数的排序

N是一个合法的正整数

基于比较的排序（能够比大小，< = >有定义）

只讨论内部排序（在无限大的内存空间里排序）

稳定性：任意两个相等的数据，排序前后的相对位置不发生改变


**没有一种排序在任何情况下都是最快最好的！** 


### 冒泡排序

```c
void Bubble_Sort(ElementType A[], int N)
{
  for(P = N-1; P>=0; P--)
  {
    flag = 0; // 判断有没有发生交换
    for(i = 0; i<P; i++) //一趟冒泡
    {
      if(A[i] > A[i+1]) //稳定
      {
        Swap(A[i], A[i+1])
        flag = 1; //发生了交换
      }
    }
    if(flag = 0) //从始至终无交换，说明排好序了
      break;
  } 
```


最好情况：顺序 $T=O(N)$

最坏情况：逆序 $T=O(N^2)$


好处：非常简单！所有的待排序元素在一个单向链表里，其他排序不容易做到！

坏处：表现不好


### 插入排序

摸牌的过程 

```c
void Insertion_Sort(ElementTy[e A[], int N)
{
  for(P = 1; P < N; P++)
  {
    Tmp = A[P]; // 摸牌
    for(i = P; i >0 && A[i-1]>Tmp; i--)
      A[i] = A[i-1]; //移出空位
    A[i] = Tmp;  //新牌落位
  }
} 
```


最好情况：顺序 $T=O(N)$

最坏情况：逆序 $T=O(N^2)$

 

### 时间复杂度下界

逆序对：对于下标i<j，如果A[i]>A[j]，则称(i, j)是一对逆序对inversion


交换相邻2个元素，正好消去一个逆序对


如果逆序对的个数 $I$

插入排序： $T(N, I) = O(N+I)$

如果这个序列基本有序，则插入排序简单高效


定理：任意N个不同元素组成的序列平均具有 $\frac{N(N-1)}{4}$个逆序对

定理：任意仅以交换相邻两元素来排序的算法，其平均时间复杂度为 $\Omega (N^2)$


为了效率，我们必须：

&ensp;&ensp;&ensp;&ensp;每次消去不止一个逆序对

&ensp;&ensp;&ensp;&ensp;每次交换相隔较远的逆序对




