# å¿«é€Ÿæ’åº

æ€è·¯ï¼š**åˆ†è€Œæ²»ä¹‹** 

é€‰ä¸»å…ƒpivot

ä¼ªç æè¿°

```c
void Quicksort(ElementType A[], int N)
{
  if(N < 2) return;
  pivot = A[]ä¸­é€‰å–ä¸€ä¸ªä¸»å…ƒï¼›
  å°†S = {A[] \ pivot}åˆ†æˆ2ä¸ªç‹¬ç«‹å­é›†;
    A1={aå±äºSï½œa <= pivot}å’Œ A2={aå±äºSï½œa >= pivot};
  A[] = Quicksort(A1, N1)+ A[] + Quicksort(A2, N2);
} 
```


æœ€å¥½æƒ…å†µï¼š $T(N) = O(NlogN)$


### é€‰ä¸»å…ƒ

ä»¤pivot = A[0]ï¼Ÿå•¥bï¼Œå¤ªğŸ¤æ…¢äº†

éšæœºå–pivotï¼Ÿrand()å‡½æ•°ä¸è¡Œ

å–å¤´ä¸­å°¾çš„ä¸­ä½æ•°

```c
ELementType Median3(ELementType A[], int Left, int Right)
{
  int Center = (Left + Right) / 2;
  if(A[Left] > A[Center])
    Swap(&A[Left], &A[Center]);
  if(A[Left] > A[Right])
    Swap(&A[Left], &A[Right]);
  if(A[Center] > A[Right])
    Swap(&A[Center], &A[Right]);
  // A[Left] <= A[Center] <= A[Right]
  Swap(&A[Center], &A[Right-1]) //å°†pivotè—åˆ°å³è¾¹ 
  // æ¥ä¸‹æ¥åªéœ€è¦è€ƒè™‘A[Left+1]åˆ°A[Right-2] 
  return A[Right-1];
}
```


### 
å­é›†åˆ’åˆ†

å¿«é€Ÿæ’åºä¹‹æ‰€ä»¥å¿«ï¼Œæ˜¯å› ä¸ºä¸»å…ƒä¸€æ¬¡æ€§è¢«æ”¾åœ¨äº†æ­£ç¡®çš„ä½ç½®

![](image/image.png)

![](image/image_1.png)

å¦‚æœæœ‰å…ƒç´ æ­£å¥½ç­‰äºpivotæ€ä¹ˆåŠï¼Ÿ

&ensp;&ensp;&ensp;&ensp;åœä¸‹æ¥äº¤æ¢ï¼Ÿå¤æ‚åº¦ä½

&ensp;&ensp;&ensp;&ensp;ä¸ç†å®ƒï¼Œç»§ç»­ç§»åŠ¨æŒ‡é’ˆï¼Ÿå¤æ‚åº¦å¤ªé«˜ï¼Œæ¯æ¬¡ä¸»å…ƒè¢«æ”¾åœ¨æœ«å°¾

&ensp;&ensp;&ensp;&ensp;

å¿«é€Ÿæ’åºçš„é—®é¢˜ï¼šç”¨é€’å½’...å¯¹å°è§„æ¨¡æ•°æ®ï¼Œå¯èƒ½è¿˜ä¸å¦‚æ’å…¥æ’åºæ¥çš„å¿«

è§£å†³æ–¹æ¡ˆï¼šå½“é€’å½’çš„æ•°æ®è§„æ¨¡å……åˆ†å°ï¼Œåˆ™åœæ­¢é€’å½’ï¼Œç›´æ¥è°ƒç”¨ç®€å•æ’åº

å®šä¹‰ä¸€ä¸ªcutoffé˜ˆå€¼ï¼Œå°äºcutoffæ—¶ï¼Œå°±ä¸é€’å½’äº†


### 
ç®—æ³•å®ç°

```c
void Quicksort(ELementType A[], int Left, int Right)
{  if(Cutoff <= Right-Left)
  {
    Pivot = Median3(A, Left, Right);
    i = Left;
    j = Right-1;
    for(; ; )
    {
      while(A[++i] < Pivot);
      while(A[--j] > Pivot);
      if(i < j)
      {
        Swap(&A[i], &A[j]);
      }else
      {
        break;
      }
    }
    Swap(&A[i], &A[Right-1]);
    Quicksort(A, Left, i-1);
    Quicksort(A, i+1, Right);
  }
  else
  {
    Insertion_Sort(A+Left, Right-Left+1)
  }
}

void Quick_Sort(ElementType A[], int N)
{
  Quicksort(A, 0, N-1)
} 
```


### ç›´æ¥è°ƒç”¨åº“å‡½æ•°

```c
/* å¿«é€Ÿæ’åº - ç›´æ¥è°ƒç”¨åº“å‡½æ•° */

#include <stdlib.h>

/*---------------ç®€å•æ•´æ•°æ’åº--------------------*/
int compare(const void *a, const void *b)
{ /* æ¯”è¾ƒä¸¤æ•´æ•°ã€‚éé™åºæ’åˆ— */
    return (*(int*)a - *(int*)b);
}
/* è°ƒç”¨æ¥å£ */ 
qsort(A, N, sizeof(int), compare);
/*---------------ç®€å•æ•´æ•°æ’åº--------------------*/


/*--------------- ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¯¹ç»“æ„ä½“Nodeä¸­çš„æŸé”®å€¼keyæ’åº ---------------*/
struct Node {
    int key1, key2;
} A[MAXN];
 
int compare2keys(const void *a, const void *b)
{ /* æ¯”è¾ƒä¸¤ç§é”®å€¼ï¼šæŒ‰key1éå‡åºæ’åˆ—ï¼›å¦‚æœkey1ç›¸ç­‰ï¼Œåˆ™æŒ‰key2éé™åºæ’åˆ— */
    int k;
    if ( ((const struct Node*)a)->key1 < ((const struct Node*)b)->key1 )
        k = 1;
    else if ( ((const struct Node*)a)->key1 > ((const struct Node*)b)->key1 )
        k = -1;
    else { /* å¦‚æœkey1ç›¸ç­‰ */
        if ( ((const struct Node*)a)->key2 < ((const struct Node*)b)->key2 )
            k = -1;
        else
            k = 1;
    }
    return k;
}
/* è°ƒç”¨æ¥å£ */ 
qsort(A, N, sizeof(struct Node), compare2keys);
/*--------------- ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¯¹ç»“æ„ä½“Nodeä¸­çš„æŸé”®å€¼keyæ’åº ---------------*/
```







